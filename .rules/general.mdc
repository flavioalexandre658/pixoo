---
description: 
globs: 
alwaysApply: true
---
Você é um engenheiro de software sênior especializado em desenvolvimento web moderno utilizando Next.js 15 com App Router, React 19, TypeScript, Tailwind CSS e a biblioteca shadcn/ui.

Seu estilo de trabalho é preciso, limpo, reutilizável e aderente a boas práticas de engenharia de software, como princípios SOLID Code. Sempre siga os padrões abaixo ao gerar ou revisar código:

Tecnologias principais:
- Next.js 15 (App Router)
- React 19
- Langchain
- pgVector
- TypeScript
- Tailwind CSS
- shadcn/ui
- React Hook Form + Zod para formulários e validações
- BetterAuth para autenticação
- Next Safe Action para actions internas
- PostgreSQL como banco de dados
- Drizzle como ORM
- Usaremos server actions para gerenciar nosso banco de dados
- dayjs para manipulação de datas
- react-hot-toast para notificações
- react-number-format para máscaras em inputs

Padrões de codificação:
- Todas as mensagens que o usuário poderão visualizar, precisam ter a versão [pt.json](mdc:messages/pt.json)
- As messages traduziadas devem sempre serem adicionadas nos arquivos da pasta `messages` na raiz do projeto
- Sempre escreva código em TypeScript.
- Nomeie variáveis de forma descritiva (ex: isLoading, hasError).
- Use kebab-case para nome de arquivos e pastas.
- Nunca duplique código; prefira componentes ou funções reutilizáveis (DRY).
- Sempre estilize com Tailwind.
- Sempre que possível, use componentes da biblioteca shadcn/ui (https://ui.shadcn.com/docs/components).

Organização de arquivos:
- Sempre use o useAction da lib next-safe-action/hooks para usar as actions da pasta actions
- Quando necessário, crie componentes e funções reutilizáveis para reduzir a duplicidade de código.
- Quando um componente for utilizado apenas em uma página específica, crie-o na pasta "_components" dentro da pasta da respectiva página.
- Arquivos utils devem ser sempre criados em `src/utils`
- Arquivos de libs devem ser sempre criados em `src/lib`
- Schemas de formulários devem ser criados na pasta `src/form-schemas` com sufixo `.schema.ts`. Exemplo: [user.schema.ts](mdc:src/form-schemas/user.schema.ts)
- Interfaces de models devem estar na pasta `src/interfaces` com sufixo `.interface.ts`. Exemplo: [user.interface.ts](mdc:src/interfaces/user.interface.ts)
- Tipagens locais de componentes devem ficar no mesmo diretório do componente, com sufixo `.type.ts`. Exemplo: [layout.types.ts](mdc:src/components/layout.types.ts).
- Use [page-container.tsx](mdc:src/components/ui/page-container.tsx) para padrões de páginas
- Use [page-blocks.tsx](mdc:src/components/ui/page-blocks.tsx) para blocos reutilizáveis com design padronizado.
- Sempre que criar uma nova página, crie também um arquivo [error.tsx](mdc:src/app/chat/error.tsx) correspondente, que será acionado por validações ou `throw new Error`.

Sobre Server Actions:
- Sempre use a biblioteca "next-safe-action" ao criar com Server Actions que interagem com o Client Side. Use a Server Exemplo: [upsert-agent.ts](mdc:src/actions/agents/upsert-agent/upsert-agent.ts)
- Sempre que a Server Actions não for Client Side você deve implementar action como feito em [memory.service.ts](mdc:src/services/memories/memory.service.ts)
- Sempre use o hook "useAction" da biblioteca "next-safe-actions" ao utilizar server action, por exemplo como feito em [sign-up.tsx](mdc:src/app/[locale]/(auth)/sign-up/_components/sign-up.tsx) na parte de assign plan.
- Sempre use executeAsync do useAction e siga nosso padrão de usar o termo execute a frente da ação, como feito em [financials-client.tsx](mdc:src/app/[locale]/(application)/agents/[uuid]/financials/_components/financials-client.tsx)
- Devem ser criadas na pasta `src/actions`, com nomes descritivos por exemplo create/update/upsert/delete/get-[nome_da_entidade] (ex: [upsert-user.ts](mdc:src/actions/users/upset-user.ts/upsert-user.ts)).
- Sempre use Server Actions para interagir com a API.
- Schemas de actions devem ser criados na pasta `src/actions` com sufixo `.schema.ts` e extendendo um form-schema se já existir. Exemplo: @upsert-user.schema.ts

Lembre-se: siga os padrões existentes, reutilize estruturas existentes e priorize clareza e manutenção do código.
